<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-04-20T22:34:02-04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Nigel Charleston - Programmer</title><subtitle>This is Nigel Charleston's Portfolio</subtitle><entry><title type="html">Io: Script Iteration</title><link href="http://localhost:4000/game/development/2020/04/20/Project-Blue-Gold.html" rel="alternate" type="text/html" title="Io: Script Iteration" /><published>2020-04-20T00:00:00-04:00</published><updated>2020-04-20T00:00:00-04:00</updated><id>http://localhost:4000/game/development/2020/04/20/Project-Blue-Gold</id><content type="html" xml:base="http://localhost:4000/game/development/2020/04/20/Project-Blue-Gold.html">&lt;p&gt;The gold sprint is the Final deliverable for Project Blue, now known officially as Io. During the entire sprint, I spent the entirety of my time iterating upon my implementation of the Acrobat AI script.&lt;/p&gt;

&lt;h1 id=&quot;acrobats-not-triggering-5-hours&quot;&gt;Acrobat’s Not Triggering: (5 hours)&lt;/h1&gt;

&lt;p&gt;In the beta build of the game, it was descovered by one of the lead developers for the studio that the Acrobat enemies in the level would not move. When the player reached the Aggro range of the Acrobat, it would take no action:&lt;/p&gt;

&lt;div style=&quot;width:100%;height:0;padding-bottom:57%;position:relative;&quot;&gt;&lt;iframe src=&quot;https://giphy.com/embed/M9lZJO8oNKibT4Y5mw&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;position:absolute&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/M9lZJO8oNKibT4Y5mw&quot;&gt;via GIPHY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This bug was very frustrating for me to hear about. In my local development scene, the Acrobat appeared to be working fine. However, I realized that my development scene could have been out of date with the official scene for the game. In order to figure out this issue, I first reviewed my acrobat movement code, making sure I did not accidently add a change that would prevent the enemy from moving. I placed several debug statements in my code that would print information regarding the internal state of the Acrobat. From the statements that I saw, I could confirm that the coroutines I set up to move the Acrobat were not activating.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/AcrobatTriggeringIssues.PNG&quot; alt=&quot;TriggerIssues&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Something outside of the Acrobat script was causing it not to move. The only component on the prefab that could be problematic is the Aggro child.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/AcrobatAggroObject.PNG&quot; alt=&quot;Aggro&quot; /&gt;&lt;/p&gt;

&lt;p&gt;While reviewing the Aggro object’s settings, I noticed that there was a variable named “Raycast Line of Sight” which I paid no attention to while working on the Acrobat. I began to suspect that either this setting, or the Raycast Layer Mask, was causing tthe Acrobat to not move. These variables belong to the EnemyAggro script, which contains logic for how the enemy uses its circle collider to detect players. Which looking over the code, I found a problematic section that could cause the issue:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private void OnTriggerEnter2D(Collider2D other) {
        // Invoke OnAggro when the player enters the enemy's trigger or enter search mode
        if(other.gameObject.CompareTag(&quot;Player&quot;))
        {

            if (raycastLineOfSight)
            {
                isSearching = true;
            }
            else
            {
                target = other.gameObject;
                OnAggro.Invoke();
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Due to several project deadlines that came up in my other classes, I did not have time to completely understand the enemyAggro code. However, it appears that by having the raycastLineOfSight variable on, the script is unable to obtain a reference to the Acrobat’s target (which is the player). After turning this variable off, the Acrobat’s in the level began to move again:&lt;/p&gt;

&lt;div style=&quot;width:100%;height:0;padding-bottom:57%;position:relative;&quot;&gt;&lt;iframe src=&quot;https://giphy.com/embed/j03uuJLlkwiD7BDH9E&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;position:absolute&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/j03uuJLlkwiD7BDH9E&quot;&gt;via GIPHY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It is likely that this setting was intended for an enemy which actively patrols for the player: the stalker, for instance, will move back and forth in a segment of the level until it finds a player to attack. The Acrobat, on the other hand, remains idle on the ceiling until a player enters its aggro range. I was reliving that this was the only issue causing the Acrobat to not move.&lt;/p&gt;

&lt;p&gt;After fixing the bug with the Acrobat’s aggro, I had to ensure that the Acrobats in the official scene, known as the Crystal Cave, behaved appropriately. After my fix was merged into the development branch, I immediately went into the crystal cave’s scene, and turned off the raycast variable on all the Acrobats. Overall, while frustrating, it was overall straightforward to fix.&lt;/p&gt;

&lt;h1 id=&quot;acrobat-ai-iteration-25-hours&quot;&gt;Acrobat AI Iteration: (25 hours)&lt;/h1&gt;

&lt;p&gt;A few weeks ago, I changed the Acrobat’s prefab collider into a trigger. This change was intended to improve the collisions that the enemy would have with the player. If the object were a trigger, it would stop the player from moving the Acrobat and interrupting its movement patterns. However, while this seemed to work decently when I first implemented it, my change was later found to be buggy. The acrobats would frequently fly through the Crystal Cave’s terrain, while attack the player from unexpected angles:&lt;/p&gt;

&lt;div style=&quot;width:100%;height:0;padding-bottom:57%;position:relative;&quot;&gt;&lt;iframe src=&quot;https://giphy.com/embed/l1Bn7XpAq0QVOtUUDH&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;position:absolute&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/l1Bn7XpAq0QVOtUUDH&quot;&gt;via GIPHY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This bug made the Acrobat frustrating to fight during the Wolverinsoft Studio playtests. Moreover, I did not intend for this issue to occur: at the time that I tested the change, I was unable to reproduce such a jarring bug. For the remainder of the Studio’s gold sprint, the last deliverable before the game was released, I spent a significant amount of time fixing this bug, and improving upon the movement patterns of the Acrobat.&lt;/p&gt;

&lt;p&gt;I spent several hours attempting to get the trigger collider code to better detect Terrain. I tried using the Unity library’s “IsTouching” function to prevent non-player objects from triggering the Acrobat collider. In addition, I put in tag comparisions in order to detect the type of object which triggered the Acrobat: upon hitting an object tagged as “Terrain” or “Hazard”, I would set the acrobat’s velocity to zero. However, these changes were not enough to consistently prevent the Acrobat’s from penetrating the terrain.&lt;/p&gt;

&lt;p&gt;With the final deadline looming, and after several failed attempts, I ended up switch the acrobat’s collider back into a default box collider. The default box collider works better thna&lt;/p&gt;</content><author><name></name></author><summary type="html">The gold sprint is the Final deliverable for Project Blue, now known officially as Io. During the entire sprint, I spent the entirety of my time iterating upon my implementation of the Acrobat AI script.</summary></entry><entry><title type="html">Project Blue: Acrobat Collisions and AI Improvement</title><link href="http://localhost:4000/game/development/2020/04/06/Project-Blue-Pre-Beta.html" rel="alternate" type="text/html" title="Project Blue: Acrobat Collisions and AI Improvement" /><published>2020-04-06T00:00:00-04:00</published><updated>2020-04-06T00:00:00-04:00</updated><id>http://localhost:4000/game/development/2020/04/06/Project-Blue-Pre-Beta</id><content type="html" xml:base="http://localhost:4000/game/development/2020/04/06/Project-Blue-Pre-Beta.html">&lt;p&gt;Over the past few weeks, I focused my efforts on improving the Acrobat enemy. I improved the Acrobat’s repose mechanic so that it will move to a nearby ceiling after attacking the player. I also wrote code that allows the Acrobat that to move side by side (instead of from floor to ceiling), as well as a basic collision and bounce back when the Acrobat collides with the player.&lt;/p&gt;

&lt;h1 id=&quot;acrobat-ai-better-repose-15-hours-significant-time-debugging&quot;&gt;Acrobat AI: Better Repose (15 Hours) (significant time debugging)&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/files/AcrobatArt.PNG&quot; alt=&quot;FinalAcrobatArt&quot; /&gt;
&lt;img src=&quot;/files/AcrobatMovement.png&quot; alt=&quot;Movement&quot; /&gt;
The Acrobat is an enemy which has two movement behaviors: Leap and Repose. When the enemy leaps, it attacks the player’s current location. When it has completed this attack, after a short cooldown, it will do a repose move where it moves back to the ceiling. Originally, the enemy would simply return to its original location:&lt;/p&gt;

&lt;div style=&quot;width:100%;height:0;padding-bottom:54%;position:relative;&quot;&gt;&lt;iframe src=&quot;https://giphy.com/embed/kxl8E6lOuWr2QSqtaz&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;position:absolute&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/kxl8E6lOuWr2QSqtaz&quot;&gt;via GIPHY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;While this approach worked fine, I talked to my project lead to see if there were a better way of doing the repose. I came up with the idea of modifying the repose so that instead of the Acrobat returning to its original position, it could instead move to a part of the ceiling that is closest to the player.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/NearestCeiling.PNG&quot; alt=&quot;NewAcrobatMovement&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now, instead of traveling back to its origin, the Acrobat could present a more interesting challenge to the player. With this movement style, it is possible for the Acrobat to briefly pursue the player if they (player) try to outmaneuver from it. Also, this would potentially make the Acrobat’s movement seem more natural. This is the final result of implementing this change:&lt;/p&gt;

&lt;div style=&quot;width:100%;height:0;padding-bottom:49%;position:relative;&quot;&gt;&lt;iframe src=&quot;https://giphy.com/embed/ggFDUwYu7rc3Krtde8&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;position:absolute&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/ggFDUwYu7rc3Krtde8&quot;&gt;via GIPHY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Implementing better repose for the Acrobat took a significant amount of time to debug: it took me a day or so figure out my previously mentioned improvement. While googling ways to send the Acrobat in a direction, I came across the idea of vector orthogonality. The idea behind this Linear Algebra concept is that if you have two vectors that form a 90-degree angle, there are considered perpendicular to each other. Moreover, if I added these two vectors together, then the result is a diagonal vector. From here, I read Unity’s documentation on Vector2 (x,y) vectors and was able to come up with the math that I needed to get the Acrobat to repose in the desired direction:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/RightDiagonal.PNG&quot; alt=&quot;RightDiagonal&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I modified the coroutine controlling the repose movement to calculate the direction the player is from the Acrobat. Then, depending on which direction the player was, my script would then move the Acrobat diagonally in that direction. I took advantage of the Vector2 Interfaces Up, Left, and Right vectors to calculate the new direction of the Acrobat. By adding a Vector2.Up (0, 1) and a Vector2.Right (1, 0), you get a vector that is diagonal in the right direction (1, 1).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/LeftDiagonal.PNG&quot; alt=&quot;LeftDiagonal&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can also produce a left diagonal vector (-1, 1) by adding a Vector2.Up (0,1) to a Vector2.Left (-1, 0). When the player’s direction is calculated, we set the Acrobat’s velocity to be equal to the correct diagonal direction, and move it there.&lt;/p&gt;

&lt;p&gt;Moreover, I ran into several issues with Acrobat’s movement that took the majority of my time to debug. In one issue, the Acrobat would become stuck on the wall, moving in the direction of the player. However, once it got stuck in a corner, it would no longer move.&lt;/p&gt;

&lt;p&gt;To figure out the cause of the issue, I wrote a function that would print out the state of the private variables I used to implement the script, the most important of which is my variable which indicates the player’s current state. What I noticed was that this issue was happening between the enemy gained, and suddenly lost, aggro. I traced this issue to two boolean variables I was using to decide whether or not the enemy should perform a behavior, and change state: “canAct” and “midAction”&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private void Action()
    {
        if(canAct &amp;amp;&amp;amp; !midAction)
        {
            if(enemyCurrentState == State.DORMANT)
            {
                enemyScript.desiredVelocity = Vector2.zero;
            }
            else if(enemyCurrentState == State.LEAP)
            {
                StartCoroutine(LeapAttack());
                enemyCurrentState = State.REPOSE;
            }
            else if(enemyCurrentState == State.REPOSE)
            {
                StartCoroutine(Repose());
                enemyCurrentState = State.LEAP;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In my deaggro function, which is called when the player exits the enemy’s aggro range, I forgot to reset the midAction variable to be false. As a result, the midAction variable became always set to true and would lock the Acrobat out of performing another action when aggro is obtained again.&lt;/p&gt;

&lt;p&gt;To resolve this issue, I got rid of the midAction variable. I realized if I properly set my canAct bool to false when every I entered a coroutine, and set it back to true immediately after the given coroutine’s yield call returns, I could always guarantee that another coroutine would not start until the current one finishes. Moreover, I made sure the reset canAct and the Acrobat’s state variable so that it could properly act again when the player regains its aggro.&lt;/p&gt;

&lt;h1 id=&quot;acrobat-collision-knockback-10-hours&quot;&gt;Acrobat: Collision Knockback (10 hours)&lt;/h1&gt;

&lt;p&gt;For my next assignment, I was tasked with making the Acrobat’s collisions with the player seem more natural. An idea that my pod lead gave me was to have the acrobat bounce away from the player upon collision and have it drop to the ground. In the previous implementation of the acrobat script, collisions were not handled at all. As a result, the Acrobat would become stuck midair where it hit the player until it reposed back to the ceiling. By implementing a basic knockback mechanic, interactions between the player and acrobat could look smoother, and more realistic.&lt;/p&gt;

&lt;p&gt;To begin implementing this, I began to think of different ways that the bounce-back could be handled. Essentially, the acrobat must move in a curve from the point of contact from the player to the ground. After doing some searching online, the idea of bezier curves came to mind:&lt;/p&gt;

&lt;div style=&quot;width:100%;height:0;padding-bottom:42%;position:relative;&quot;&gt;&lt;iframe src=&quot;https://giphy.com/embed/H7g2aeaA307GKUockQ&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;position:absolute&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/H7g2aeaA307GKUockQ&quot;&gt;via GIPHY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In a bezier curve, there are 3 points: P0 is the starting point for the moving object. P2 is the endpoint, and P1 is the midpoint between P0 and P2. When the object moves, it will move in a curve formed by connecting the lines (P0, P1) and (P1, P2), and the object will move along this curve until it reaches P2. I incorporated the bezier curve into my code, and got smooth, curved, movement as a result:&lt;/p&gt;

&lt;div style=&quot;width:100%;height:0;padding-bottom:49%;position:relative;&quot;&gt;&lt;iframe src=&quot;https://giphy.com/embed/Qub9DYfrNIRBi7vec3&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;position:absolute&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/Qub9DYfrNIRBi7vec3&quot;&gt;via GIPHY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;However, an issue shows up when the player collides with the enemy in midair: with my attempted implementation, the enemy will begin to move down but will stop when it reaches the y-axis of the player. This results in the Acrobat becoming stuck in midair and within the environment background:&lt;/p&gt;

&lt;div style=&quot;width:100%;height:0;padding-bottom:49%;position:relative;&quot;&gt;&lt;iframe src=&quot;https://giphy.com/embed/YrAw2xmYms6biUhUOL&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;position:absolute&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/YrAw2xmYms6biUhUOL&quot;&gt;via GIPHY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If there was a way to calculate the endpoint, such that we knew ahead of time where the best place for the Acrobat to land after being knocked back, then this issue would be solved by calculating P2 = (the desired x, desired y). However, without knowing where the level designers will place the acrobat, and no functions available in the unity library (from my knowledge), this would not be possible.&lt;/p&gt;

&lt;p&gt;For the sake of getting my task done on time, I ended up using Unity’s physic’s engine to implement the knockback mechanic:&lt;/p&gt;

&lt;div style=&quot;width:100%;height:0;padding-bottom:49%;position:relative;&quot;&gt;&lt;iframe src=&quot;https://giphy.com/embed/mC0fnqvJ82D40Qd4Cs&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;position:absolute&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/mC0fnqvJ82D40Qd4Cs&quot;&gt;via GIPHY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Upon colliding with the player, I calculated the direction of the impact within Unity’s OnCollisionEnter function. From here, I define a new state to transition the enemy to KNOCKBACK. In this state, I apply a constant force in the opposite direction of the collision, throughout several frames. As a result, a rough, but functional, knockback is achieved.&lt;/p&gt;

&lt;p&gt;While implementing this functionality, I had to spend several hours debugging the Acrobat’s movement behaviors. One of the major issues I faced with this script was applying the force onto Acrobat over several frames. I struggled with multiple bugs, including the Acrobat’s movement being broken after one leap, as well as an issue with the force not being applied at all. Most of these issues came down to making sure that the script’s internal variables were updated to enable the acrobat to transition back to the REPOSE state after the knockback is complete. I also resolved an issue where the Acrobat could lose aggro while being knocked back. Overall, using the 2D physics engine was straightforward, and the knockback works well. However, I will continue to improve upon the Acrobat’s functionality in the coming weeks leading up the project’s “Gold” deliverable.&lt;/p&gt;

&lt;h1 id=&quot;side-by-side-acrobat-5-hours&quot;&gt;Side-By-Side Acrobat (5 hours):&lt;/h1&gt;

&lt;p&gt;As an additional task, I modified my Acrobat script so that it could move the Acrobat Side-by-Side, instead of moving from ceiling to floor:&lt;/p&gt;

&lt;div style=&quot;width:100%;height:0;padding-bottom:50%;position:relative;&quot;&gt;&lt;iframe src=&quot;https://giphy.com/embed/QW9KJ6aXPmchvpQCyc&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;position:absolute&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/QW9KJ6aXPmchvpQCyc&quot;&gt;via GIPHY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The side by side functionality can be activated by level designers in the unity editor; a public boolean can be checked which enables the Acrobat to move in this way. This could be useful for placing the Acrobat in narrow pits, as a trap to players. However, if the player collides with the enemy, then it would fall to the ground due to the knockback implementation. To address this issue, I spoke to one of the WolvenSoft Studio leads; he suggested making the Acrobat’s 2D box collider into a trigger. This would prevent the Acrobat from being moved by the player: and would allow for it to perform its movement behaviors without being interrupted by any other physical object. However, some tweaking to the prefab (and potentially some code changes) may be necessary to get this working. I will attempt to implement this feature in the next sprint and will discuss its results (successful or not) in the next blog post.&lt;/p&gt;</content><author><name></name></author><summary type="html">Over the past few weeks, I focused my efforts on improving the Acrobat enemy. I improved the Acrobat’s repose mechanic so that it will move to a nearby ceiling after attacking the player. I also wrote code that allows the Acrobat that to move side by side (instead of from floor to ceiling), as well as a basic collision and bounce back when the Acrobat collides with the player.</summary></entry><entry><title type="html">Project Blue: Coroutines and Game Tuning</title><link href="http://localhost:4000/game/development/2020/03/22/Project-Blue-Developments.html" rel="alternate" type="text/html" title="Project Blue: Coroutines and Game Tuning" /><published>2020-03-22T00:00:00-04:00</published><updated>2020-03-22T00:00:00-04:00</updated><id>http://localhost:4000/game/development/2020/03/22/Project-Blue-Developments</id><content type="html" xml:base="http://localhost:4000/game/development/2020/03/22/Project-Blue-Developments.html">&lt;p&gt;For this development sprint, I contributed to the AI of the Dropper enemy, created a prefab for another enemy in production, and did fine tuning on the Acrobat prefab. I adjusted the acrobats properties (speed and aggro settings) so that it is at the right level of difficulty.&lt;/p&gt;

&lt;h1 id=&quot;dropper-ai-15-hours&quot;&gt;Dropper AI: (15 hours)&lt;/h1&gt;

&lt;p&gt;My main assignment for the past week was to develop the movement script for the Dropper enemy:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/Dropper.png&quot; alt=&quot;Dropper&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The dropper is a flying enemy that moves above the player and drops projectiles on the player. They have a simple movement pattern: they move strictly left and right on the x-axis, chaging their direction every few seconds:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/DropperMovement.PNG&quot; alt=&quot;DropperMovement&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To start coding the Droppers behavior, I used a similar approach to how I developeed the &lt;a href=&quot;https://nigel2016.github.io/game/development/2020/03/02/Project-Blue-Extended-PreAlpha-Sprint.html&quot;&gt;acrobat&lt;/a&gt;, where I use a state machine to map out each of the acrobat’s movement patterns. With this states, can easily convert them into code that makes the dropper move in the desired pattern:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/DropperStateMachine.PNG&quot; alt=&quot;DropperStateMachine&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The enemy can be in 3 states: IDLE, LEFT, and RIGHT. In the IDLE state, the enemy will take no action, waiting in anticipation for the enemy. When the player (Io) enters the enemy’s aggro collider, a Unity event is called from the enemyAggro script that will transition the dropper from IDLE state to LEFT state. At this point, the dropper will move a a constant pace about the x-axis (the initial direction of the player) for a either a 2 seconds or until it collides with an object in the environment. At this point, the dropper then transitions to the RIGHT state, and will move in the opposite direction for 2 seconds. The script can be modified to make the dropper move in a particular direction for a longer period of time, or be programmed to change directions upon traveling a certain distance. If the player exits the enemy’s aggro collider, a DeAggro event is triggered from the enemyAggro script which ends the dropper’s movement and returns them to the IDLE state.&lt;/p&gt;

&lt;div style=&quot;width:100%;height:0;padding-bottom:59%;position:relative;&quot;&gt;&lt;iframe src=&quot;https://giphy.com/embed/SuIftmtORNk5bNfbxe&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;position:absolute&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/SuIftmtORNk5bNfbxe&quot;&gt;via GIPHY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;While developing this enemy’s movement, I ran into a few interesting issues. Firstly, I noticed that if the player exits the enemy’s aggro collider, then enters it again, the dropper will move away from the player. This was caused due to my assumption that the player would continue to move right after killing the dropper or ignoring it. In order to make this less awkward, I modified the script so that it could detect the direction the player entered the dropper’s collider. In this way, the script could then trigger the state the corresponds to the player’s current direction, and move towards them.&lt;/p&gt;

&lt;p&gt;Another issue I faced dealt with the timing of the coroutine functions as the DeAggro event was being triggered. For this script, I utilized coroutines to execute the dropper’s movement. Coroutines are functions which execution can be paused for a specified period of time, during which execution control is returned to Unity. Normal functions must have all its instructions be executed before returning. With coroutines, the dropper can move in a single direction across multiple frames before moving in the oppoiste direction.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/MultiCoroutines.PNG&quot; alt=&quot;dropperSynchonization&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The issue with the DeAggro event was that if another coroutine was waiting to return at the same time the DeAggro function was executing, it could overwrite the change to state (IDLE) the DeAggro event causes. This results in the dropper continuing to move in the opposite direction, despite the player having exited the enemy’s aggro range.&lt;/p&gt;

&lt;p&gt;In order to fix this issue, I used a function in Unity’s library called “StopAllCorountines()” which deactivates any coroutines that may be still running by the time the DeAggro event is triggered. If there happens to be no coroutines running, “StopAllCorountines()” does nothing. The inclusion of this function fixed the issue, and guarantees that no other coroutine overwites the state transition to IDLE.&lt;/p&gt;

&lt;h1 id=&quot;acrobat-design-prefab-creation-5-hours&quot;&gt;Acrobat Design: Prefab Creation (5 hours)&lt;/h1&gt;

&lt;p&gt;For my next tasks, I created a prefab of the Acrobat enemy: a game object which contains all the properties necessary for the enemy to be functional in the game. The prefab will also allow for level designers to select and place multipe Acrobats in the level easily, with all of their stats configured and ready to go. The components of the acrobat can be described with the following hierarchy:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/DropperPrefab.PNG&quot; alt=&quot;dropperPrefab&quot; /&gt;&lt;/p&gt;

&lt;p&gt;One of the most important components to the Acrobat is its rigidbody. The rigidbody gives the enemy motion under Unity’s underlying physics engine. For the remaining components, I divided them into two child objects parented to the prefab:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;View: This child contains an animator component which will be used to store animations made for the Acrobat. The other component is the sprite renderer, which will store the Acrobat’s appearance.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Aggro: This child contains the components necessary for the enemy to detect player movement and react. The EnemyAggro script requires a circle collider which, when the player hits it, will cause the script to fire a Unity event. This event can be used to activate functions contained in the AcrobatAI script that executes the enemy’s movement behavior. In addition, the “FlyingCharacterScript” is used to actually move the Acrobat, given an (x,y) velocity.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The prefab makes placing Acrobats in the game’s levels easier. Designers can also configure public variables tied to each of the componenets in order to adjust an enemy’s behavior (aattack speed, aggro collider width, etc.)&lt;/p&gt;

&lt;h1 id=&quot;acrobat-design-tuning-behaviors-10-hours&quot;&gt;Acrobat Design: Tuning behaviors (10 hours)&lt;/h1&gt;

&lt;p&gt;My next assignment with the Acrobat was to fine tune the acrobat prefab. I had to determine what the right level of difficulty should be for the acrobat; I adjusted its prefab properties in order so that the acrobat’s interactions with the player are fair and balanced. In addition, I had to figure out what the right level placements for an acrobat enemy should be.&lt;/p&gt;

&lt;p&gt;Starting with the level layout, I drew out several possiblities and assessed how ideal they would be in the final game. My criteria for idealness are: What placement would allow for the enemy to most effectively challenge the player? Which placement makes since given the implmentation of the Acrobat’s AI script, and the design specification?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/OptimalAcrobatPlacement.PNG&quot; alt=&quot;dropperPrefab&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1) The enemy is attached to a ceiling which hangs below the player. This is the placement initially proposed in the acrobat’s design specification.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/SideBySidePlacementAcrobat.PNG&quot; alt=&quot;dropperPrefab&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2) The enemy could be attached to walls side by side, and can essentially be used to ambush a player as their fall down a long corridor.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/SuboptimalPlacementAcrobat.PNG&quot; alt=&quot;dropperPrefab&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3) The acrobat could be placed at the same level as the player, and attack them face to face.&lt;/p&gt;

&lt;p&gt;I determined that the best acrobat placement would be 1). This made the most sense given the intial design of the Acrobat, which aimed to create an enemy which promoted player anticipation and movement. By having the enemy on the ceiling, it would prompt the player to be alert of their surrounds, and to ready their reflexes in order to antipate an attack. This placement would also allow for multiple acrobats to placed in groups, and ing the player to defeat groups of enemies using the warping mechanic.&lt;/p&gt;

&lt;p&gt;2) Would not work as well: The acrobat’s would only have one attempt to attack the player before it reaches the end of the corridor. It also does not present a challenge to the player, in that they would be able to skip the encounter without using the weapon teleportation mechanic.&lt;/p&gt;

&lt;p&gt;3) Is not ideal. The Acrobat’s repose would not work: if the player is heading towards the acrobat, the next avaliable wall to repose from would be too far away. In other words, the player could simply jump over the acrobat, and skip the fight encounter entirely. There is also an issue with grouping acrobats with this placment. if all the acrobats are side to side with this placement, then they are more likely to collide with each other, and create akward fight encounters with the player.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/PrefabEditing.PNG&quot; alt=&quot;dropperPrefabEditing&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To further tune the enemy, I adjusted several properties of its prefab:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The gravity scale and drag properties on the prefab’s rigidbody were set to 0. This allows for the acrobat to not be effected by gravity while it hangs on the wall, and lerps to attack the player’s recent location.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The cooldown timers that delay the transtion from an acrobat’s attack and repose were both set to 2 seconds. I found these settings were the best so that the enemy could still aggressively attack the player, bbut give them enough time to react.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On the Aggro child object, I set the circle collider’s radius to 10. This was the most ideal setting for having acrobats grouped together in large, open spaces. For tighter spaces, the designers will be able to lower the aggro range as they see fit.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Overall, I felt these changes would make the acrobat a more effective enemy. However, playtesting is necessary to see how the player interacts with the enmy. From there, more precise changes can be made to the prefab in order to balance its difficulty.&lt;/p&gt;</content><author><name></name></author><summary type="html">For this development sprint, I contributed to the AI of the Dropper enemy, created a prefab for another enemy in production, and did fine tuning on the Acrobat prefab. I adjusted the acrobats properties (speed and aggro settings) so that it is at the right level of difficulty.</summary></entry><entry><title type="html">Project Blue: Extended Pre-Alpha Sprint</title><link href="http://localhost:4000/game/development/2020/03/02/Project-Blue-Extended-PreAlpha-Sprint.html" rel="alternate" type="text/html" title="Project Blue: Extended Pre-Alpha Sprint" /><published>2020-03-02T00:00:00-05:00</published><updated>2020-03-02T00:00:00-05:00</updated><id>http://localhost:4000/game/development/2020/03/02/Project-Blue-Extended-PreAlpha-Sprint</id><content type="html" xml:base="http://localhost:4000/game/development/2020/03/02/Project-Blue-Extended-PreAlpha-Sprint.html">&lt;p&gt;Leading up to the Spring Break Sprint for Project Blue, I worked on making AI for the game’s Acrobat enemy. In addition, I working on a DevOps solution that will allow for our web developer’s work to be automatically saved and pushed to the studio’s github repo. I also created several prototypes inspired by games that I have been playing recently.&lt;/p&gt;

&lt;h1 id=&quot;acrobat-ai&quot;&gt;Acrobat AI:&lt;/h1&gt;

&lt;p&gt;For this sprint, my main task was to implement the movement behaviors for the Acrobat enemy. The Acrobat is an agile enemy which has the following movement patterns:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/AcrobatMovement.png&quot; alt=&quot;Movement&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The enemy must first detect the player by using a script called “EnemyAggro.” The enemy is surrounded by a sphere collider; when the player enter’s this spear, an event called “OnAggro” is triggered. Upon detecting the player, the enemy will leap to the players location in order to detect them. Upon executing this attack, there is a brief cooldown, and then the enemy will reset by performing a “repose” to a nearby wall.&lt;/p&gt;

&lt;p&gt;In order to implement this behavior, I modeled the Acrobats behavior to a finite state machine:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/AcrobatStateMachine.PNG&quot; alt=&quot;StateMachine&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In the Acrobat’s movement script, one function is used to control the movements of the enemy. We can model the movements into three states: “dormant”, “leap”, and “repose”. In the script, there is a check to determine what the current state of the enemy is, then the enemy’s movement is modify by directly accessing its “FlyingMovementScript” component (component that moves the enemy given a desired velocity).&lt;/p&gt;

&lt;p&gt;In the dormant sage, we make sure that the enemy is not movement by zeroing out their velocity. Upon an “OnAggro” event, the enemy’s aggro script will execute a function that changes the acrobat’s state to Leaping, and then set the enemy’s velocity to launch into the direction of the player. If the enemy still has sight of the player, it will transition to the “repose” stage, and return to its original location. This behavior is repeated until the player exits the Acrobat’s aggro range. A deaggro event is executed in thsi case, and the enemy is transitioned back to “dormant.”&lt;/p&gt;

&lt;div style=&quot;width:100%;height:0;padding-bottom:54%;position:relative;&quot;&gt;&lt;iframe src=&quot;https://giphy.com/embed/kxl8E6lOuWr2QSqtaz&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;position:absolute&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/kxl8E6lOuWr2QSqtaz&quot;&gt;via GIPHY&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;rsync-version-control&quot;&gt;Rsync Version Control:&lt;/h1&gt;

&lt;p&gt;Another tasks that I was assigned with recently is releated to DevOps. Currently, we have a web developer who is working on Project Blue’s promotional website.&lt;/p&gt;

&lt;p&gt;Whenever they write code to modify the website’s interface, they have to manually add, commit, and send the changes that they make to the server which is hosting the website. My task was to research rsync, a file transfering tool avaliable in Linux systems, and come up with a solution that would automatically update the repository whenever the a change is made to it. To begin this task, I developed a script which allows for me to automatically send changes I make to my website repository to a repository belonging to my CAEN account (a computing resource provided to computer science students at the University of Michigan):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#! /bin/bash&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;DIRECTORY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;~/test_project_blue&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;SOURCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/mnt/c/users/123ch/Nigel2016.github.io/*&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;DESTINATION&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ndcharle@oncampus-course.engin.umich.edu&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do
    &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;rsync &lt;span class=&quot;nt&quot;&gt;-ruve&lt;/span&gt; ssh &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;SOURCE&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;DESTINATION&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;:&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;DIRECTORY&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;sleep &lt;/span&gt;10
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The script here will perform the rsync command every 10 seconds: it takes code in a source directory and attempts to send it to “${DESTINATION}:${DIRECTORY}.” The only issue with this script is that “oncampus-course.engin.umich.edu” is a domain belonging to my University, and requires me to login using my CAEN password whenever I want to establish a connection. A better solution would require for this login process to be done automatically, if not skipped.&lt;/p&gt;

&lt;p&gt;Moreover, the actual solution should look something like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/rsync.PNG&quot; alt=&quot;rsync&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The script must be ran as a process on the server where the website’s repository is located. Rsync must be able to establish a connection with the web developer’s computer, and pull any changes that the developer makes into the server repository. I will continue to work on this solution in the comming weeks, and will give an update in the next blog post.&lt;/p&gt;

&lt;h1 id=&quot;enemies-spawning-enemies&quot;&gt;Enemies spawning enemies:&lt;/h1&gt;

&lt;p&gt;A few weeks ago, Nikhil, the enemy pod leader, was thinking about a prototype concept of an enemy that spawns sub enemies. This is a pattern
that is common in many games: one infamous example is from the Library level in Halo Combat Evolved:&lt;/p&gt;

&lt;figure class=&quot;video_container&quot;&gt;
  &lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/90-8dTwn7-4?start=675&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/figure&gt;

&lt;p&gt;In this level, “flood” are the primary enemies to the player. When the player shoots the larger flood, they split into smaller, more agile, opponents. This level has been an annoyance to those in the Halo community, as these flood enemies not only spawn infinitely, but are relentless when grouped together.&lt;/p&gt;

&lt;p&gt;I began to think of how this could be implemented in project blue. Two methods came to mind:
    -There can be enemies that are deactivated hidden in the level. When a trigger in the environment is tripped, they are activated. 
    -Enemies can be spawned from an object pool: while the player is engaged with a superior foe, smaller opponents can spawn from a 
     fixed location in the enviornment.&lt;/p&gt;

&lt;p&gt;For the first idea: I drew a rough sketch of what this would look like in a 2D game:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/enemyTriggered.PNG&quot; alt=&quot;disableEnabledEnemies&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can have a fixed container of hidden enemies. When the player enters the aggro range of an opponent, we simply iterate through the container,
and activate each of the enemies’s game objects. This is a straightforward implementation which a developer could quickly implement: create the 
hidden foes, then place them into the game enviornment. We then need to setup an aggro script so that we can activate the hostiles on a Unity aggro event. A demonstration of this is below:&lt;/p&gt;

&lt;div style=&quot;width:100%;height:0;padding-bottom:54%;position:relative;&quot;&gt;&lt;iframe src=&quot;https://giphy.com/embed/QU4LFwb6HXUqVJBL7D&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;position:absolute&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/QU4LFwb6HXUqVJBL7D&quot;&gt;via GIPHY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;However, you would need to have many of these objects in your game scene at once. Depending on avaliable resources, this may prove to be costly. Moreover, there is no point in these objects being in the game enviornment if they have not been triggered yet. In addition, you would need to ensure that there is logic in your game code so that all of these enemies do not spawn at once. This is where object pooling might be useful:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/ObjectPool.PNG&quot; alt=&quot;ObjectPool&quot; /&gt;&lt;/p&gt;

&lt;p&gt;With the object pool method, you can place an invisible “portal” within your game enviornment. When the player gets the attention of an enemy, an event can be sent to this portal, telling it to spawn some enemies. To ensure that the player is not overwhelmed, you can write logic to control the maximum number of enemies that spawn from this portal at a time. When the enemy is killed, the spawn portal can be destroyed. With this method, you could have a manageble means of spawning infinite enemies while a player is enaged with a more superior opponent. In addition, you spawn enemies exactly when you need them, as opposed to keeping them idle in the enviornment.&lt;/p&gt;

&lt;p&gt;However, great care has to be taken when designing game mechanics that revolved around respawning opponents. As mentioend in the Halo example, respawning enemies can be a great hinderance to the player’s progress, and not challenge them in a meaningful way. Killing the same enemy repeatly over a long strech of gameplay is arguably not a sound way of keeping audiences engaged with the experience.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion:&lt;/h1&gt;

&lt;p&gt;One of the biggest challenges in this sprint was to balance my work on the studio project with my other classes. This past week, I had a midterm in my Operating System’s class (EECS 482), in addition to a project being due in this class a few days before. This was by far one of my most stressful weeks while being a student at the University of Michigan. EECS 482 has a negative atmosphere around it: it is considered by many to be one of the hardest classes at the University, with time consuming (difficult) projects and hard exams. I am doing my best to equally distribute time across all of the class I am taking this semester, using resources such as google calendar to block specific times to focus on specific subjects. In addition, I am reaching out to other students taking the class, so that I can form study groups to prepare for the final exam.&lt;/p&gt;

&lt;p&gt;In addition, I must ensure that I seek out additional assignments for Project Blue, to go alongside my mandatory ones. I am currently expected to contribute 30 hours biweekly to the project. However, I have not been assigned enough work from my pod leader in order to reach this. To ensure that I am working full time, I will come up with interesting features to experiment with and implement during the future sprints. I have played several games recently (such as the phenomenal Celeste) and have ideas for concepts from those games I would like to recreate. Although they may not end up in the game, working on these featurres will give me more experience programming gameplay, and will help me sharpen my Unity and C# skills.&lt;/p&gt;</content><author><name></name></author><summary type="html">Leading up to the Spring Break Sprint for Project Blue, I worked on making AI for the game’s Acrobat enemy. In addition, I working on a DevOps solution that will allow for our web developer’s work to be automatically saved and pushed to the studio’s github repo. I also created several prototypes inspired by games that I have been playing recently. Acrobat AI: For this sprint, my main task was to implement the movement behaviors for the Acrobat enemy. The Acrobat is an agile enemy which has the following movement patterns: The enemy must first detect the player by using a script called “EnemyAggro.” The enemy is surrounded by a sphere collider; when the player enter’s this spear, an event called “OnAggro” is triggered. Upon detecting the player, the enemy will leap to the players location in order to detect them. Upon executing this attack, there is a brief cooldown, and then the enemy will reset by performing a “repose” to a nearby wall. In order to implement this behavior, I modeled the Acrobats behavior to a finite state machine: In the Acrobat’s movement script, one function is used to control the movements of the enemy. We can model the movements into three states: “dormant”, “leap”, and “repose”. In the script, there is a check to determine what the current state of the enemy is, then the enemy’s movement is modify by directly accessing its “FlyingMovementScript” component (component that moves the enemy given a desired velocity). In the dormant sage, we make sure that the enemy is not movement by zeroing out their velocity. Upon an “OnAggro” event, the enemy’s aggro script will execute a function that changes the acrobat’s state to Leaping, and then set the enemy’s velocity to launch into the direction of the player. If the enemy still has sight of the player, it will transition to the “repose” stage, and return to its original location. This behavior is repeated until the player exits the Acrobat’s aggro range. A deaggro event is executed in thsi case, and the enemy is transitioned back to “dormant.” via GIPHY Rsync Version Control: Another tasks that I was assigned with recently is releated to DevOps. Currently, we have a web developer who is working on Project Blue’s promotional website. Whenever they write code to modify the website’s interface, they have to manually add, commit, and send the changes that they make to the server which is hosting the website. My task was to research rsync, a file transfering tool avaliable in Linux systems, and come up with a solution that would automatically update the repository whenever the a change is made to it. To begin this task, I developed a script which allows for me to automatically send changes I make to my website repository to a repository belonging to my CAEN account (a computing resource provided to computer science students at the University of Michigan): #! /bin/bash DIRECTORY=&quot;~/test_project_blue&quot; SOURCE=&quot;/mnt/c/users/123ch/Nigel2016.github.io/*&quot; DESTINATION=&quot;ndcharle@oncampus-course.engin.umich.edu&quot; while true; do sudo rsync -ruve ssh ${SOURCE} ${DESTINATION}:${DIRECTORY} sleep 10 done The script here will perform the rsync command every 10 seconds: it takes code in a source directory and attempts to send it to “${DESTINATION}:${DIRECTORY}.” The only issue with this script is that “oncampus-course.engin.umich.edu” is a domain belonging to my University, and requires me to login using my CAEN password whenever I want to establish a connection. A better solution would require for this login process to be done automatically, if not skipped. Moreover, the actual solution should look something like this: The script must be ran as a process on the server where the website’s repository is located. Rsync must be able to establish a connection with the web developer’s computer, and pull any changes that the developer makes into the server repository. I will continue to work on this solution in the comming weeks, and will give an update in the next blog post. Enemies spawning enemies: A few weeks ago, Nikhil, the enemy pod leader, was thinking about a prototype concept of an enemy that spawns sub enemies. This is a pattern that is common in many games: one infamous example is from the Library level in Halo Combat Evolved: In this level, “flood” are the primary enemies to the player. When the player shoots the larger flood, they split into smaller, more agile, opponents. This level has been an annoyance to those in the Halo community, as these flood enemies not only spawn infinitely, but are relentless when grouped together. I began to think of how this could be implemented in project blue. Two methods came to mind: -There can be enemies that are deactivated hidden in the level. When a trigger in the environment is tripped, they are activated. -Enemies can be spawned from an object pool: while the player is engaged with a superior foe, smaller opponents can spawn from a fixed location in the enviornment. For the first idea: I drew a rough sketch of what this would look like in a 2D game: We can have a fixed container of hidden enemies. When the player enters the aggro range of an opponent, we simply iterate through the container, and activate each of the enemies’s game objects. This is a straightforward implementation which a developer could quickly implement: create the hidden foes, then place them into the game enviornment. We then need to setup an aggro script so that we can activate the hostiles on a Unity aggro event. A demonstration of this is below: via GIPHY However, you would need to have many of these objects in your game scene at once. Depending on avaliable resources, this may prove to be costly. Moreover, there is no point in these objects being in the game enviornment if they have not been triggered yet. In addition, you would need to ensure that there is logic in your game code so that all of these enemies do not spawn at once. This is where object pooling might be useful: With the object pool method, you can place an invisible “portal” within your game enviornment. When the player gets the attention of an enemy, an event can be sent to this portal, telling it to spawn some enemies. To ensure that the player is not overwhelmed, you can write logic to control the maximum number of enemies that spawn from this portal at a time. When the enemy is killed, the spawn portal can be destroyed. With this method, you could have a manageble means of spawning infinite enemies while a player is enaged with a more superior opponent. In addition, you spawn enemies exactly when you need them, as opposed to keeping them idle in the enviornment. However, great care has to be taken when designing game mechanics that revolved around respawning opponents. As mentioend in the Halo example, respawning enemies can be a great hinderance to the player’s progress, and not challenge them in a meaningful way. Killing the same enemy repeatly over a long strech of gameplay is arguably not a sound way of keeping audiences engaged with the experience. Conclusion: One of the biggest challenges in this sprint was to balance my work on the studio project with my other classes. This past week, I had a midterm in my Operating System’s class (EECS 482), in addition to a project being due in this class a few days before. This was by far one of my most stressful weeks while being a student at the University of Michigan. EECS 482 has a negative atmosphere around it: it is considered by many to be one of the hardest classes at the University, with time consuming (difficult) projects and hard exams. I am doing my best to equally distribute time across all of the class I am taking this semester, using resources such as google calendar to block specific times to focus on specific subjects. In addition, I am reaching out to other students taking the class, so that I can form study groups to prepare for the final exam. In addition, I must ensure that I seek out additional assignments for Project Blue, to go alongside my mandatory ones. I am currently expected to contribute 30 hours biweekly to the project. However, I have not been assigned enough work from my pod leader in order to reach this. To ensure that I am working full time, I will come up with interesting features to experiment with and implement during the future sprints. I have played several games recently (such as the phenomenal Celeste) and have ideas for concepts from those games I would like to recreate. Although they may not end up in the game, working on these featurres will give me more experience programming gameplay, and will help me sharpen my Unity and C# skills.</summary></entry><entry><title type="html">Project Blue: Pre-Alpha 1 Sprint</title><link href="http://localhost:4000/game/development/2020/02/17/Project-Blue-PreAlpha-Sprint.html" rel="alternate" type="text/html" title="Project Blue: Pre-Alpha 1 Sprint" /><published>2020-02-17T00:00:00-05:00</published><updated>2020-02-17T00:00:00-05:00</updated><id>http://localhost:4000/game/development/2020/02/17/Project-Blue-PreAlpha-Sprint</id><content type="html" xml:base="http://localhost:4000/game/development/2020/02/17/Project-Blue-PreAlpha-Sprint.html">&lt;p&gt;This will be my first blog post regarding my contributions to the WolverineSoft Studio’s game project (currently dubbed Project Blue). We are conceptualizing and building a new action adventure game from the ground up using Unity as our game engine.&lt;/p&gt;

&lt;p&gt;What I do:&lt;/p&gt;

&lt;p&gt;I am a programmer and designer on the Enemies team of the Project. As a designer, I am tasked with creating concepts for enemies that the player will encounter throughout their experience, and designing their movements and attacks. As a programmer, I am responsible for programming the artificial intelligence for the enemies, and creating C# scripts which other developers throughout the studio can use to tune the enemies behavior as they debug features in Unity’s editor.&lt;/p&gt;

&lt;p&gt;Design:&lt;/p&gt;

&lt;p&gt;For this sprint, I was tasked with drafting two enemy design concepts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The first enemy, the Gungnir, is a range based thrower that challenges the player into mastering the game’s signature mechanic. The player’s main use of navigating through the game enviornment is a weapon teleportation technique, where they can throw their weapon and rapidly warp to its destination. The Gungnir throws high velocity projectiles at the player. The idea behind this enemy is that ordinary manuevers (jumping and running) cannot be used to avoid its attacks. The weapon teleport mechanic must be utilized in order to dodge the Gungnir’s fast attacks and to get close enough to the enemy in order to defeat it.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The second enemy, the Sniper, is a slow moving enemy that defy’s gravity and shoots homing projectiles at the player. Rather than sticking to the ground, the Sniper moves through the environment by utilizing portals to warp and flank the player from behind. They fire bursts of magic missiles which will target’s its prey with great precision. The motivation behind this enemy is to give the player another practical means of using the weapon teleportation mechanic to outmaneuver and kill opponents. All the while, they are a relatively easy enemy to defeat once the player realizes they can deflect the enemies projectiles. An idea I had for this enemy is if the player warps into, and strikes the missiles, they can deflect the missiles back at the Sniper, and kill it instantly.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While coming up with these concepts, I thought about how they could positiviely enhance the player’s experience. How can the enemies challenge the player’s understanding of the game’s mechanics, without being a huge burden on their progress? In what ways can enemies be used to make the weapon teleportation mechanic useful in combat, in addition to ordinary exploration? My intent was to design enemies which motivate the player to learn the weapon teleportation mechanic, and to challenge them into using this mechanic as a means of survival.&lt;/p&gt;

&lt;p&gt;Programming:&lt;/p&gt;

&lt;p&gt;During this sprint, I was also responisble for creating a Flying Character Script. Given a 2D velocity (x,y), the script had to move a game object in that velocity’s direction:&lt;/p&gt;

&lt;div style=&quot;width:100%;height:0;padding-bottom:54%;position:relative;&quot;&gt;&lt;iframe src=&quot;https://giphy.com/embed/MdMOBgALWG84rSDJiB&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;position:absolute&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://giphy.com/gifs/MdMOBgALWG84rSDJiB&quot;&gt;via GIPHY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Through a public variable in my script, a developer can control the movement of the object by inputing a x and y value into the Unity editor. This script can also be referenced by other scripts to make objects fly, making it foundational for flying enemies that will eventually be featured in the game.&lt;/p&gt;

&lt;p&gt;My main difficulty with writing the script was figure out which methods in unity would be best for moving the object. There are many different methods avaliable that can manipulate the position of a game object.Some of these involve getting an objects “transform” component, and manually setting the x, y, and z positions of the component, or modifying the “RidgidBody” components movement by applying a force with the “AddForce” function. What I ultimately stored a reference to the “RidgidBody” in the script, then directly modifed it’s velocity variable using a public variable. I believed that this would be the simplest way to modify the object. In the fututre, I will ask the lead developers on clarification regarding best practices for manipulating 3D objects as are code base becomes more complex.&lt;/p&gt;

&lt;p&gt;Summary:&lt;/p&gt;

&lt;p&gt;Overall, this sprint went smoothly. I believe that I was given tasks which were clear in scope, and could be done within the tiem constrait of the sprint (2 weeks). The only downside was that I was not given much work to complete. This is understandable, since the project has only just finished its conceptual phase. As development ramps up, there will be an abundance of opportunities to contribute code and design to the game.&lt;/p&gt;</content><author><name></name></author><summary type="html">This will be my first blog post regarding my contributions to the WolverineSoft Studio’s game project (currently dubbed Project Blue). We are conceptualizing and building a new action adventure game from the ground up using Unity as our game engine.</summary></entry></feed>